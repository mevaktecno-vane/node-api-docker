Trabajo Práctico: Git + Docker + API Express

•	: ¿Qué hace git clone y dónde sitúa el control de versiones?
El comando git clone en Git realiza dos funciones principales:
.	Descarga un repositorio remoto completo: copia los archivos, el historia de commits, ramas (branches) y etiquetas (tags) de un repositorio remoto a la máquina local.
.-	Configura el control de versiones automáticamente: inicializa un nuevo repositorio Git local (con git init implicito), agrega el repositorio remoto como origin y descarga la última versión del código (por defecto, la rama principal, como main o master)
El control de versiones se almacena dentro del directorio del proyecto clonado, en una carpeta oculta llamada .git. Esta carpeta contiene:
•	Objects/: datos de archivos, commits y árboles (base de datos de Git)
•	Refs/: punteros a ramas (heads/), etiquetas (tags/) y remotos (remotes/)
•	HEAD: apunta a la rama o commit actual
•	Config: configuración específica del repositorio
•	Index: área de preparación (staging área)

-	¿Qué es un Dockerfile y por qué Docker cachea capas?
Dockerfile es un archivo de txto que contene una serie de instrucciones para construir una imagen de Docker. Cada una de estas instrucciones añade una nueva “capa” a la imagen (cada capa representa un cambio en el sistema de archivos)
Docker construye imágenes en capas (layers), y cada instrucción del Dockerfile genera una nueva capa. El caching de capas optimiza el proceso por:
-	Velocidad en builds recurrentes
•	Si una capa no cambia, Docker reutiliza su versión cachead en lugar de reconstruirla.
•	Ejemplo: Si requirements.txt no cambia, no se reinstalan dependencias.
 -Eficiencia de almacenamiento
•	Las capas cacheadas se comparten entre imágenes (ej: múltiples imágenes con la misma capa base).
•	Reduce el espacio en disco y el tiempo de descarga (docker pull solo baja capas nuevas).
- Flujo de desarrollo ágil
•	Al modificar solo el código de tu app (ej: línea en app.py):
o	Las capas anteriores (dependencias, config) se reutilizan.
o	El build tarda segundos en lugar de minutos.


•	Diferencia entre git add y git commit.
•	•  git add .: selecciona todos los archivos modificados para ser incluidos en el próximo commit.
•	•  git commit: guarda un snapshot de esos archivos en el historial de Git, con un mensaje que describe el cambio.

Comando		git add						git commit
Propósito		Prepara cambios (los staged)				Guarda cambios en el historial
Dónde actúa	Área de staging (índice)				Repositorio local (carpeta .git)
Función		Selecciona qué cambios se incluirán en el próximo commit	Crea una instantánea permanente de los cambios preparados
Analogía		Agregar productos al carrito de compras			Confirmar la compra y obtener el ticket
			

•	¿Qué es un PR y cómo facilita la colaboración?
Un Pull Request (PR) es una propuesta de cambio sobre el código de un repositorio. Permite que otros revisen lo que hiciste antes de fusionarlo (merge) con la rama principal (generalmente main o master).
Un Pull Request es una funcionalidad de GitHub que permite:
.	Proponer cambios en un repositorio (propio o ajeno).
.	Solicitar que el dueño del repositorio revise y fusione tus modificaciones en la rama principal (ej: main).
.	Gestionar colaboración en proyectos, especialmente en equipos o open source.
Facilita la colaboración porque:
- Revisión de código (Code Review)
Los mantenedores pueden:
Comentar en líneas específicas de código.
Sugerir mejoras.
Aprobar (Approve) o solicitar cambios (Request changes).
- Integración controlada
Los cambios no se fusionan automáticamente:
Requieren aprobación explícita.
Pueden configurarse reglas (ej: 2 aprobaciones mínimas).
Previene errores en la rama principal.
- Pruebas automatizadas (CI/CD)
GitHub ejecuta tests automáticos en el PR:
Si fallan, se bloquea el merge.
Ejemplo: Verifica que tu código no rompa el build.
- Discusión y documentación
Todo el debate técnico queda registrado en el PR.

Útil para:
Entender por qué se hizo un cambio (git blame).
Onboarding de nuevos desarrolladores.
- Gestión de contribuciones externas (Open Source)
Permite a cualquiera proponer mejoras:
Usuario hace fork → implementa → abre PR.
Mantenedores revisan y deciden si fusionar.
Ejemplo: Arreglar un bug en React.js sin acceso directo al repo.

¿Qué implica el versionado semántico de tu imagen Docker (1.0, 2.0…)?
El versionado semántico en Docker sigue la lógica de indicar la evolución y compatibilidad de la imagen:
1.0 → Primera versión estable, funcional y lista para uso.
2.0 → Cambios importantes que rompen compatibilidad con la versión anterior.
1.1, 1.2… → Mejoras menores, agregan funcionalidades pero son compatibles hacia atrás.
1.0.1, 1.0.2… → Correcciones de errores o pequeños ajustes sin agregar funcionalidades nuevas.
Esto es importante porque otros pueden tirar docker pull usando una versión específica y asegurarse de que siempre se ejecute el mismo entorno, evitando cambios inesperados si actualizas la imagen.

¿Cómo funciona el caching de capas en Docker y por qué es relevante para optimizar builds?
Docker divide la imagen en capas, cada instrucción del Dockerfile genera una capa nueva.
•	Si una capa no cambió desde la última build, Docker la reutiliza desde la caché en lugar de reconstruirla.
•	Si una capa cambia, esa y todas las capas posteriores se vuelven a construir.
Ejemplo: Si solo cambias el código fuente, las capas del FROM y RUN pip install… se reutilizan, ahorrando tiempo y recursos.
Es clave ordenar el Dockerfile para que lo que cambia más seguido (como el código) vaya al final y no rompa la caché de capas anteriores.

¿Qué diferencias hay entre un commit “ligero” y uno “pesado” en términos de contenido y contexto?
*Commit ligero: Cambios pequeños, claros y enfocados en una sola cosa (ej. corregir un typo, actualizar un archivo).
	Ventajas: fácil de revisar, revertir y entender en el historial.
	Contexto: la descripción del commit explica exactamente qué se cambió.
*Commit pesado: Muchos cambios juntos, que afectan múltiples partes del proyecto (ej. agregar una funcionalidad completa + modificar configuración + corregir errores no relacionados).
	Desventajas: difícil de revisar y revertir; no queda claro cuál cambio hizo qué.
	Contexto: la descripción puede ser general, pero no detalla cada cambio.
En buenas prácticas de Git, conviene que la mayoría sean commits ligeros y frecuentes, para mantener un historial limpio y entendible.


